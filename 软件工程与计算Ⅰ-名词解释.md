# 软件工程与计算Ⅰ-名词解释



> 根据GitHub上内容（软工一里面那几个名词解释）、刘钦老师的PPT以及YDJSIR自身经验整理得来。
>
> 本部分对应PPT：07-18除去与JVM和字节码相关的内容

## 软件（Software）

软件是一系列按照特定顺序组织的电脑数据和指令的集合。

## 编程语言

### 低级语言

1. 低级语言分机器语言和汇编语言，这两种语言都是面向机器的语言，和具体机器的指令系统密切相关。

2. 机器语言：是机器的自然语言，是唯一一种计算机能直接理解并执行的语言。由二进制码组成，每一串二进制码叫做一条指令。作为最底层的程序设计语言，只提供最基础的系统操作，例如算术运算、位操作、数据移动与布尔逻辑运算等。

   > 难于使用机器语言编写程序，不利于软件的跨平台使用。

3. 汇编语言：**对机器语言的上层抽象形成的。**

   （优）**使用符号来表示操作码和地址码，提高了程序的可读性；汇编程序自动处理存储分配；允许程序员使用十进制表达数据。**

   （缺）**必须用汇编程序把它翻译成机器语言目标程序，计算机才能执行。**

   > JAVA的字节码机制则比较特殊，JAVA编译出来的字节码仍然依赖于虚拟机运行而不是直接在实体机上跑。
   
### 高级语言

1. 高级语言使用易于理解的符号和英文单词组成的语句，独立与计算机硬件系统。

   **（优）**不依赖与底层硬件，易学，易读，易移植，程序自动化程度高，易于开发。

   **（缺）**程序长，程序运行速度慢，程序无法直接访问、控制硬件。

   **（解决办法）**设计高级编程语言与低级语言之间调用的接口。该用低级语言追求性能的时候就用低级语言写，否则就用高级语言写。

   > C语言有时候也被称为中级语言，因为它实际上可以生成任意对应机器语言，但又具有部分高级语言特性。
   >
   > 可以参考第一至五代编程语言的分类（《计算机文化》，机械工业出版社）
   
### 程序设计语言分类

   1.根据变量被指定类型的时间：动态类型语言和静态类型语言。

   2. **动态类型语言**：在程序运行期间才会检查变量的类型，即在声明变量时不需要指定其类型，而是在第一次对其赋值时隐式地指定类型。如Python。
   
   3. **静态类型语言**：要求在程序运行前就确定变量的类型，即在声明变量时需要显式的指定其类型。如Java。

   4.根据变量类型在程序运行中是否改变：强类型定义语言和弱类型定义语言。

   5. **强类型定义语言**：变量一旦被指定数据类型后，除非进行自动或强制的类型转换外，变量的类型不会发生变化。如JAVA。
   6. **弱类型定义语言**：变量的类型可以忽略，一个变量在运行中可以被赋以不同类型的值。如C/C++。如这样的句子。  
   7. **Java语言是一种静态类型语言和强类型定义语言。**

   - *trapped errors*。导致程序终止执行，如除0，Java中数组越界访问
   - *untrapped errors*。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址

   语言设计时，可以定义一组*forbidden behaviors*. 它必须包括所有untrapped errors, 但可能包含trapped errors。

   对静态类型语言而言：

   - 如果类型是语言语法的一部分，在是**explicitly typed**显式类型；
   - 如果类型通过编译时推导，是**implicity typed**隐式类型, 比如ML和Haskell

|                                                              |
| ------------------------------------------------------------ |
| ![preview](https://pic3.zhimg.com/b0aeb7ffd1667b9162e5329154d43777_r.jpg?source=1940ef5c) |

### 变量

用于表示数据存储在语言中的抽象。可以看作抽象的容器，用于在程序运行过程中存放数据。

2. 6个方面的特性：名字（标识变量）、值（变量中存放的数据）、地址（变量在内存中存放的位置）、类型（变量所属的数据类型）、作用域（变量在程序中可见的范围）、生存期（变量从创建到消亡的时间）。
3. 对变量的基本操作：赋值（将数值存放到变量中）；取值（从变量中取出当前存放的数值）。
4. 成员变量：用于存放表示类的属性的数值。在类中声明，在整个类范围内可见。用标识符表示名字，需要指定其类型。会采用默认值初始化，但鼓励编程时对其进行初始化。
5. 局部变量：在方法内部临时存放数值。声明在方法中，作用域由大括号决定。
6. Java中不允许在内部作用域中声明的局部变量与外部作用域中声明的局部变量重名，但成员变量与局部变量可以重名。当在方法中声明了与成员变量重名的局部变量后，使用该标识符时会默认为局部变量。如果需要使用成员变量，可以用this关键字来表示。

| 物理的⻆度           | 逻辑的⻆度               | 语义的⻆度          |
| -------------------- | ------------------------ | ------------------- |
| 计算机的数据存储单元 | 软件模型中的抽象数据单元 | 类的属性/⽅法的状态 |

注意静态变量与final变量。

现实对象的状态→计算对象的状态→⽤程序设计语⾔常规的符号名字来模拟

由于现实对象的状态随时间要变化的 —> 符号名字的值也要变—>变量

> 怎么变？赋值语句。代价：打破**引用透明性**。

与所有状态都必须显式地操作和传递额外的参数的⽅式相⽐，通过引进赋值和将状态隐藏在局部变量的技术，我们能以⼀种更模块化的⽅式构造系统。

带有“赋值”的程序将强迫⼈们去考虑赋值的“相对顺序”，以保证每个语句所⽤的是被修改变量的正确版本。

#### 作用域与生存期

##### **作用域**：变量在程序中的可见范围。

> Java中外部作用域定义的局部变量对内部作用域中的程序是可见的，而内部作用域中定义的局部变量对外部是不可见的。

• 局部变量：⽅法内部

• 属性字段：对象内部

• 静态变量：全局

##### **生存期**：变量从创建到被撤销的时间。（动态，静态）

C/C++：需要主动调用析构方法

JAVA：垃圾回收机制。一个对象存活的时间由其引用的存活周期所决定。标记-清除-压缩（Mark-Sweep-Compact），年轻、年老和永久。

#### 值

| 类型  | 范围                                                         |
| ----- | ------------------------------------------------------------ |
| byte  | -128 ~ 127                                                   |
| short | -32768 ~ 32767                                               |
| int   | -2147483648 ~ 2147483647 (10^9以内无障碍)                    |
| long  | -9223372036854775808 ~ 9223372036854775807 (10^18以内无障碍) |
| char  | ‘\u0000’ - '\uffff' (0-65535) 注意：这里的char恰好是半个int！ |

| 这里的N有一个是符号位，这部分内容可以回顾计基的浮点数部分。  |
| ------------------------------------------------------------ |
| ![image-20200821094259693](https://oss.ydjsir.com.cn/img/image-20200821094259693.png) |

变量的名字必须由字⺟、下划线（_），或者美元符（$）开头，⽽其余部分可以是除了JAVA运算符（⽐如+、-或者*）和空白符之外的任何字符。

变量初始化部分（手动关联JVM部分）

|                                                              |                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20200821095452486](https://oss.ydjsir.com.cn/img/image-20200821095452486.png) | ![image-20200821095444419](https://oss.ydjsir.com.cn/img/image-20200821095444419.png) | ![image-20200821095507028](https://oss.ydjsir.com.cn/img/image-20200821095507028.png) |

• 直接访问：x=10（内部使⽤者）——如果方法传入的变量名与当前成员变量有冲突的，可以用this.x指代自己的成员变量；

• 间接访问：position.setX(10)——（外部使用者）

### 方法

| 物理的⻆度 | 逻辑的⻆度               | 语义的⻆度          |
| ---------- | ------------------------ | ------------------- |
| 指令块     | 软件模型中的抽象数据单元 | 类的属性/⽅法的状态 |

| 类的行为 | 对象的行为 |
| -------- | ---------- |
| 静态方法 | 成员方法   |

#### 方法接口

• 返回值 • ⽅法名 • 参数 • 个数 • 类型 • 顺序 • 抛出的异常

**运行期：** 程序执行的时间段。

#### 方法调用（这里又涉及到线程方面的问题了）

| 同步                     | 异步                       |
| ------------------------ | -------------------------- |
| 调用方法和被调用方法相关 | 调用方法和被调用方法不相关 |

#### 重载和覆盖（面向对象）

| 重载-Overload                    | 覆盖-Override                                                |
| -------------------------------- | ------------------------------------------------------------ |
| 参数不同，名字一样，是不同的方法 | 是同一个方法，具体执行的时候执行继承树中最低的那个，而且<br/>• 参数必须一致，返回值必须兼容<br/>• 方法的可达性不能降低。 |

> JAVA和C/C++中不允许仅以返回值不同进行重载

#### 三种语句：顺序、分支、循环

## 编译和解释

1. 编辑器和解释器都是讲某种高级编程语言写成的源代码转换成低级编程语言目标代码的电脑程序。

2. **编译器**：必须在翻译之前将源程序当作大的单元（通常是整个源文件）来分析，一个程序只需要被编译一次就可以多次执行。

3. 编译器的工作流程：源代码→预处理器→编译器→汇编程序→目标代码→链接器→可执行程序。

4. **解释器**：是一个执行程序的虚拟机，一次能够翻译高级语言程序的一段、一行、一条命令或一个子程序。每翻译一行程序就立刻执行，再翻译下一行，再运行，直到程序结束。

   > JAVA的字节码与JVM是一种特殊的解释器。JVM不像Python那样直接拿Python这样的高级语言源码去解释，而是解释编译后的字节码。

## 程序（Program）设计

程序设计是给出解决特定问题程序的过程，是软件构造活动中的重要组成部分。

- • 代码是⽤来读的（实践经验），是团队与维护的需要，需要重视代码规范；

- • 降低复杂度 — 分解与抽象（⽅法学）
- - 好的分解应该令分解后各个组分之间的耦合度尽可能的低！
  - 抽象之后，接⼝的复杂度变⼩，接⼝和实现之间达成⼀种契约。

- • 编程=数据结构+算法（理论逻辑）

- • 算法建模（理论逻辑）算法是计划、过程、步骤。**三大机制：基本表达式、分解（复合）、抽象**。这是每种编程语言都必须提供的。
- - 基本表达式：算术运算、逻辑运算
  - 两种思路：迭代与递归

- • 数据建模（理论逻辑）数据结构是操作的⽬标、对象。
- - 基础数据：整数、浮点数、布尔值；数据的组合：数组、结构体（数据组合）、对象（数据与行为的组合）
  - 数据的抽象：有序对

- • 编程典型场景 — 数据处理（理论逻辑）

### 命令式编程（怎么做）

> 落实到每一步怎么做。

### 声明式编程（做什么）

> 如SQL，MATLAB以及其它各类脚本等DSL（Domain Specific Language）

### 函数式编程

> 具有无状态性。枚举→过滤→映射→规约四个步骤不要忘了

柯里化：把接收多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并将返回接受余下的参数且返回结果的新函数的技术。

### 逻辑式编程

> 比如Prolog。其实是一个DFS的过程。

> 面向对象编程与结构化编程后面会有专门的章节进行详细介绍。

## 软件工程

1. IEEE的定义：

> ①将系统、规范、可度量的方法应用于软件的开发、运行和维护，即将工程应用于软件；
>
> ②对①中所述方法的研究。

2.计算机科学技术百科全书的定义：软件工程是应用计算机科学、数学及管理科学等原理，开发软件的**工程**。其中计算机科学、数学用于构建模型和算法，工程科学用于制定规范、设计范型、评估成本及确定权衡，管理科学用于计划、资源、质量、成本等管理。

现在的软件已经复杂到不是⼀个⼈能够开发出来的。

> 数学→计算机→软件⼯程

> #### 数学为计算机提供了理论基础
>
> • 现实世界的问题先转换为⼀个数学问题
>
> • 然后再⽤计算机解决这个数学问题
>
> #### 计算机有特有的软件和硬件实现：不同框架下的解决方案是不一样的！
>
> • 软件框架（编程范式：命令式、函数式）
>
> • 硬件框架（硬件结构：冯诺依曼结构、哈佛结构）
>
> ![image-20200821113803295](https://oss.ydjsir.com.cn/img/image-20200821113803295.png)

| 软件工程现状                                                 |
| ------------------------------------------------------------ |
| ![image-20200821113519400](https://oss.ydjsir.com.cn/img/image-20200821113519400.png) |

### 软件开发生命周期（SDLC）

| **软件开发生命周期（Software Development Life Cycle）**      |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 指软件产品从开发到报废的生命周期，通常周期中包括了需求分析、软件设计、实现与调试、测试与验收、部署、维护等活动。<br/>**软件开发过程**：指一个软件产品开发的方法，描述了软件开发中的活动和任务。简单的说，就是软件开发中的一系列活动。<br/>**不断移交，不断演化！** | <img src="https://oss.ydjsir.com.cn/img/image-20200821114055377.png" alt="image-20200821114055377" style="zoom:67%;" /> |

### 软件开发模式

1. **创建—修补**（牛仔编程法）

2. **瀑布模型**：描述了软件开发的基本框架。按时间顺序描述了一个软件项目的开发。核心思想是根据开发活动来分解项目。将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动。

·**优：**为项目提供了按阶段划分的检查点；当前一阶段完成后，只需要去关注后续阶段。

·**缺：**在项目各个阶段之间极少有反馈；只有在项目生命周期的后期才能看到结果。通过过多的强制完成日期和里程碑来跟踪各个项目阶段。

3. 迭代式软件开发**：根据软件项目的不同功能子集来分解项目。在迭代式开发方法中，整个开发工作被组织为一系列的短小的项目，被称为一系列的迭代。每个迭代包含了需求、设计、实施（编码）、部署、测试等各种类型的开发活动，迭代完成之后需要对迭代完成的结果进行评估，并以此为依据来制定下一次迭代的目标。**每个迭代周期结束时都应该得到一个经过测试的、集成起来的基本可用的软件产品。**

> **·优：**易于应对变更需求；逐步集成元素；尽早降低风险；有助于提高团队的士气；生成更高质量的产品；保证项目开发进度；容许产品进行战术改变；迭代流程自身可在进行过程中得到改进和精炼。
>
> ·**缺：**需求或设计中的错误往往只有到了项目后期才能够被发现；对于项目风险的控制能力较弱；软件项目常常延期完成或开发费用超出预算；项目管理人员专注于文档的完成和审核来估计项目的进展情况。

### 个人软件过程（Personal Software Process,PSP)

1. **个人软件过程：**是包括了数据记录表格、过程操作指南和规程在内的结构化框架。基本流程包括**计划**、**设计**、**编码**、**编译**、**测试**以及**总结**6个主要阶段。所有的开发活动都需要记录相应的时间日志和缺陷日志。

### 软件工程工具与调试

1. 软件开发工具根据在不同软件开发生命周期阶段中起到的作用可以分为：

- 软件需求工具：用于描述系统的需求、需求建模和需求跟踪。

- 软件设计工具：用于描述软件设计。

- 软件构造工具：用于程序设计、编码和编译，主要是集成开发环境（IDE）等。

- 软件测试工具：用于软件测试，系统缺陷检测等。

- 软件开发支撑工具：

2. **集成开发环境（IDE）**：将各种软件编程工具集成到一个应用程序中，提供一致的界面，并有效协同各个工具的使用，使得工具可以使用另外工具提供的信息，体高软件开发人员效率的应用程序。Eclipse、NetBeans等
3. 软件配置管理（Software Configuration Management,SCM）：用于跟踪和控制软件变更。包括：版本控制、变更管理和过程支持。
4. 软件版本控制（Versional Control）是软件配置管理的核心和基础。版本控制的对象是软件开发过程中涉及的计算机文件，包括源代码、库文件、图形资源文件、计划文档、需求文档、设计文档、测试文档等可以存储为计算机文件的有关资源。
5. 常见的版本控制由服务器和客户端组成。
6. 调试基本过程：重现bug，定位bug，改正bug。
7. 软件测试：使用人工和自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。
8. 为了保证软件行为能够符合人们的预期，软件开发人员需要对软件进行**验证**和**确认**工作。

**·验证**：确定某个工作阶段是否正确完成的过程，在每个工作阶段结束时进行。我们是否正确构建了软件。

**·确认**：确定整个产品是否满足用户期望，是在产品交付用户之前进行的深入细致的评估。我们是否构建了正确的软件。

**测试用例**：为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序是否正确工作。

### 需求：一种期望

IEEE对需求的定义为[IEEE610.12-1990]：

- ⑴⽤户为了解决问题或达到某些⽬标所需要的条件或能⼒；
- ⑵系统或系统部件为了满⾜合同、标准、规范或其它正式⽂档所规定的要求⽽需要具备的条件或能⼒；
-  ⑶对⑴或⑵中的⼀个条件或⼀种能⼒的⼀种⽂档化表述。

### 测试

1. 根据测试工程师设计测试案例时的视点不同：白盒测试（结构测试）、黑盒测试（功能测试）。
2. 根据在软件开发过程中测试实施的对象不同：单元测试、集成测试和系统测试。
3. 自动化单元测试（JUnit）：一个开源自动化单元测试框架。

- Verification - 检查解决⽅案的有效性：Whether do it right?
- Validation - 检查是否解决了问题：Whether do the right thing?

#### 用例

是具有共同用户目标的一系列场景的集合。UML将其定义为“在系统（或者子系统或者类）和外部对象的交互当中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种有价值的服务。

1. 用例是所有和用户某一目标相关的成功和失败场景的集合。

2. 用例用来获取系统的功能需求，而不是所有的系统需求，尤其是非功能性需求，如性能目标、安全性设计等。

### 软件系统分析与设计

1.**系统**：极其复杂的研制对象，即由相互作用和相互依赖的若干组成部分结合成具有特定功能的有机整体，而且这个系统本身又是它所从属的一个更大系统的组成部分。

2.**系统工程**：组织管理这种系统的规划、研究、设计、制造、试验和使用的科学方法。它的目的是解决总体优化问题，从复杂问题的总体入手，认为总体大于个部分之和，各部分虽较劣但总体可以优化。

3.**系统分析**：旨在研究特定系统结构中各部分（各子系统）的相互作用，系统的对外接口与界面，以及该系统整体的行为、功能和局限，从而为系统未来的变迁与有关决策提供参考和依据。

4.**系统分析阶段**：范围定义、问题分析、需求分析、逻辑设计和决策分析。

5.**面向对象分析（OOA）**：进行了需求调查后，按照面向对象的思想来分析问题，建立一个概念模型，然后可以被用来完成任务的过程。强调的是在问题领域发现和描述对象以及概念。**CRC卡**

6.面向对象分析产生的概念模型：功能模型、对象模型、动态模型。

7.软件需求文档的要求：完整性、正确性、可行性、必要性。

8.**设计**：使用分析的结果来描述系统如何实现的过程。

9.**面向对象设计（OOD）**：主要作用是对分析模型进行整理，生成设计模型提供给OOP作为开发依据。强调的是定义对象，以及这些对象如何协作来满足需求，是根据需求决定所需的类、类的操作以及类之间关联的过程。

### 自动化集成（Continuous Integration）

1. 软件集成（Integration）：将单独的软件构件合并成一个整体的软件开发活动。

2. 软件构建（Build）：将源代码转变成一个可运行的软件的过程，或最终的软件本身。其中最重要的是将源代码编译成可执行文件。

3. 现代软件集成：通常配合版本控制系统共同使用，应当做到：任何人任何时刻都应该可以从一个干净的计算机（整个计算机上只有操作系统和必要的软件开发软件）上检出当前的源代码快照，然后敲入一条命令（或点击一个按钮），就可以得到能在这台机器上运行的软件系统。

4. 集成过程：

- 从版本控制服务器签出当前的最新代码和所有的相关文件；

- 使用自动化构建工具进行构建活动，如Ant；

- 签入新的代码。

5. Ant：是一个自动化构建工具。是Java的一个类库，同时也是一个命令行工具，可以按照指定的一个用户编写的xml文件执行一些指定的任务。

> 我们的SEEC服务器采用的是Jenkins。

### 程序部署与发布

1.常见的软件发布方式：本机软件、本机和远程相结合软件、远程软件。

#### 存储程序（Stored Program）

1.计算机基于固定的硬件平台，能够执行固定的指令集。

2.计算机内存不仅存储着要进行操作的数据，还存储着指示计算机运行的指令。

## 结构化程序设计

将程序看作是一系列电脑指令序列的执行，这些序列具有基本的顺序、分支、条件转移、子函数等执行方式。

结构化方法的思想：⾃顶向下，逐步求精；具体组成：算法+数据结构。结构化程序设计将系统看做是过程的集合。

### 缺点

| 代码可读性差 | 难以维护                     |
| ------------ | ---------------------------- |
| 全局变量     | 实现变更、需求增加、需求更改 |

### 数据流图

所有的计算系统都是信息的处理和转换。

> • 接收输入，进行数据转换，输出结果；
>
> • 代表数据对象在穿过系统时如何被转换；

这里的“过程”可能需要和软件系统外的实体尤其是⼈进⾏交互。**过程就是对数据的处理。** **数据总是被处理然后完成某项业务功能。**

过程是对数据的处理，必须有输⼊，也必须有输出，输⼊数据集应该和输出数据集存在差异。

数据流是必须和过程产⽣关联的，它要么是过程的数据输⼊，要么是过程的数据输出。

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20200821001640027](https://oss.ydjsir.com.cn/img/image-20200821001640027.png) | ![image-20200821001816158](https://oss.ydjsir.com.cn/img/image-20200821001816158.png) |

所有的对象都应该有⼀个可以唯⼀标示⾃⼰的名称。

#### 数据的变化

被转换、被存储、被分布。

| 数据流图的图例                                               |
| ------------------------------------------------------------ |
| ![image-20200821000452872](https://oss.ydjsir.com.cn/img/image-20200821000452872.png) |

#### 外部实体：数据的⽣产者或者消费者

• ⼈、设备、传感器

• 计算机系统

#### 数据总是从某处来，然后流向其它的地⽅

##### 处理
- 并不⼀定是程序。

- 它可以是⼀系统程序、单个程序或程序的⼀个模块，甚⾄可以是⼈⼯处理过程；

##### 数据存储

- 并不等同于⼀个⽂件。

- 它可以是⼀个⽂件、⽂件的⼀部分、数据库元素或记录的⼀部分；它代表的是静态的数据。

##### 数据流

- 也是数据，是动态的数据。

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20200821082648368](https://oss.ydjsir.com.cn/img/image-20200821082648368.png) | ![image-20200821081858582](https://oss.ydjsir.com.cn/img/image-20200821081858582.png) |

> 一个完整的数据流图的示例。

**最概括的系统模型**→**细化数据存储和数据流**→**⼦过程**→**边界**（按照实体来划分）→**细化**

### 结构图

| 图例                                                         | 概要                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20200821083023884](https://oss.ydjsir.com.cn/img/image-20200821083023884.png) | ![image-20200821082353978](https://oss.ydjsir.com.cn/img/image-20200821082353978.png) |



|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20200821082421435](https://oss.ydjsir.com.cn/img/image-20200821082421435.png) | ![image-20200821082444613](https://oss.ydjsir.com.cn/img/image-20200821082444613.png) |

#### 几个实例

| 数字数                                                       |
| ------------------------------------------------------------ |
| ![image-20200821083048258](https://oss.ydjsir.com.cn/img/image-20200821083048258.png) |

| 课程表数据流图                                               | 课程表结构图                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20200821084725146](https://oss.ydjsir.com.cn/img/image-20200821084725146.png) | ![image-20200821084731601](https://oss.ydjsir.com.cn/img/image-20200821084731601.png) |

### 流程图

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 这个表实际上就是高中数学里面就已经提到的普通流程图。圆角矩形是输入输出，菱形是判断分支，普通矩形就是执行。<br />它对应于特定算法：<br/>• 增加课程<br/>• 检查是否可以增加<br/>• 如果可以增加<br/>• 增加课程信息<br/>• 显示已增加<br/>• 否则<br/>• 显示已经存在课程，⽆法添加<br/>与此同时，它也对应着特定的数据结构。 | <img src="https://oss.ydjsir.com.cn/img/image-20200821084853990.png" alt="image-20200821084853990" style="zoom:50%;" /> |

结构化编程从⾏为视⻆出发，⾸先根据⾏为来分解，接着设计数据来配合⾏为。

## 面向对象程序设计（OOP）

是一种程序设计方法，它使用对象作为程序的基本单元，将数据和对数据的操作封装在一起，可以提高程序设计的复用性、灵活性和可扩展性。通过众多独立的对象相互间的合作来完成系统的功能。

**其目标是可修改性，其通讯机制是消息机制。**

缺点：运行效率较低，资源占用多。

> **职责视角**
>
> 面向对象方法三要素：封装、继承、多态。

### 应对变更

#### 在有限的范围内修改：相关操作在⼀起 & 数据与操作在⼀起（封装）

#### 扩展：运⾏时动态链接（多态）比如说继承、接口之类的

### 类和对象

#### **类**

面向对象程序设计中最基本的概念，定义了一个事物的抽象特征，定义了事物的属性和对属性的操作（行为）。是一种抽象数据类型，即某类数据结构和其所具有行为的集合。

> 对现实世界中的对象建模、对抽象对象建模、降低复杂度、隔离复杂度、隐藏实现细节、限制变化所影响的范围、创建中⼼控制点

| 类图说明                                                     | 类图示范                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 上面是成员变量，下面是方法。`+`号表示`public` ，`-` 号表示private | ![image-20200821113908664](https://oss.ydjsir.com.cn/img/image-20200821113908664.png) |

> 下面是重点中的重点：依赖、关联、组合、聚合

| 名称                    | 解释与思考题中的实例                                         | UML                                                          | 代码                                                         |
| ----------------------- | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 依赖<br/>"uses a"       | 某个对象的功能依赖于另外的某个对象，⽽被依赖的对象只是作为⼀种⼯具在使⽤，⽽并不持有对它的引⽤。<br/>例如**图书馆和学生助手** | ![image-20200821112038571](https://oss.ydjsir.com.cn/img/image-20200821112038571.png) | <img src="https://oss.ydjsir.com.cn/img/image-20200821112044419.png" alt="image-20200821112044419" style="zoom:50%;" /> |
| 关联<br/>"has a"        | 关联就是某个对象会⻓期的持有另⼀个对象的引⽤，⽽⼆者的关联往往也是**相互的**。<br/>关联的两个对象彼此间没有任何强制性的约束，**只要⼆者同意，可以随时解除关系或是进⾏关联**，它们**在⽣命期问题上没有任何约定**。被关联的对象还可以再被别的对象关联，所以关联是**可以共享**的。<br/>例如**借阅记录和学⽣** | ![image-20200821112246320](https://oss.ydjsir.com.cn/img/image-20200821112246320.png) | ![image-20200821112254521](https://oss.ydjsir.com.cn/img/image-20200821112254521.png) |
| 聚合<br/>"owns a"       | 聚合是**强版本的关联**。它暗含着⼀种**所属关系以及⽣命期关系**。被聚合的对象还可以再被别的对象关联，所以被聚合对象是**可以共享**的。虽然是共享的，聚合代表的是⼀种更亲密的关系。<br/>例如**图书馆和图书** | ![image-20200821112507133](https://oss.ydjsir.com.cn/img/image-20200821112507133.png) | ![image-20200821112514406](https://oss.ydjsir.com.cn/img/image-20200821112514406.png) |
| 组合<br/>"is a part of" | 组合是关系当中的最强版本，它直接要求包含对象对被包含对象的拥有以及包含对象与被包含对象⽣命期的关系。**被包含的对象还可以再被别的对象==关联==**，所以**被包含对象**是**可以共享**的，然⽽**绝不存在两个包含对象对同⼀个被包含对象的共享**。<br/>例如**图书和图书中的一页** | ![image-20200821112715934](https://oss.ydjsir.com.cn/img/image-20200821112715934.png) | ![image-20200821112722123](https://oss.ydjsir.com.cn/img/image-20200821112722123.png) |

#### **对象**

是类的实例，有具体的属性，可以执行具体的行为。

- 每个对象都保存着描述当前特征的信息。
- 对象状态的改变必须通过调⽤⽅法实现。
- 对象的状态不能完全描述⼀个对象。每个对象都有⼀个唯⼀的身份(identity)。比如说Hashcode之类的。
- 每个对象的标识永远是不同的，状态常常也存在着差异。

##### 获取对象

###### 寻找候选对象

• 找名词 -- 类（对象）与属性

• 找动词 -- ⾏为

###### 精化对象

• 去除、冗余、不相⼲、模糊的概念

###### 重要！转化

• **没有⾏为的对象改为某个类的属性**

### 职责与角色

1. **职责：**可以理解为对象的功能。

2. 通过对需求的分析，寻找系统所需的功能，然后通过设计确定每个类的职责。

3. **单一职责原则**（**SRP**）:就一个类而言，应该仅有一个引起它变化的原因。

4. **需求**：是系统必须具有的特征，或者是客户可接受的、系统必须满足的约束，即我们要解决的“问题”。

5. **场景**：一种人们将做什么的陈述性描述，以及人们试图利用计算机系统和应用程序经验的陈述性描述。描述一个用户和系统之间交互的一系列步骤。场景是需求获取中的一种重要手段。一个场景是来自单一参与者的、具体的、关注点集中的系统单一特征的非形式化描述。

6. 理想的单⼀职责对象应该仅仅扮演⼀个⻆⾊。

| 同时运⽤的,共同来完成对协作的抽象      |                                     |
| -------------------------------------- | ----------------------------------- |
| 从⼩到⼤,将对象的⼩职责聚合形成⼤职责; | 从⼤到⼩,将⼤职责分配给各个⼩对象。 |

> ### 数据与职责在一起！寻找名词和动词以划分职责！
>
> 注意设计的完备性。一个只能装水不能倒水的杯子永远不应该出现。

### 类的协作

是对象之间的相互请求，一般表现为对象之间的方法调用。

⼀组对象共同协作履⾏整个应⽤软件的责任。

| 可以协作的对象列表       |                            |
| ------------------------ | -------------------------- |
| • 该对象⾃身             | • 任何以参数形式传⼊的对象 |
| • 被该对象直接创建的对象 | • 其所持有的对象引⽤       |

Client - Delegate - Server模型

#### 面向对象中的几个概念

- 软件：一组相互作用的对象。

- 对象：一个或多个角色的实现。

- 角色：一组相关的责任。

- 责任：执行一项任务或掌握某种信息的义务。

- 协作：对象或角色（或两者）之间的互动。

### 继承与多态

| 继承（extends）（~抽象类或普通类）                           | 何时使用？                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 子类继承了父类所有的成员变量和方法！<br/>**非抽象类中不可以有抽象方法** & **抽象类中可以有非抽象方法**。<br/>具体的类必须实现所有的抽象方法，而实现抽象方法就像子类覆盖父类方法一样。<br/>用定义抽象类的方法让某些不该被实例化的类无法实例化！<br/>抽象类本身没有用，除非他被继承有了子类。抽象类的子类可以实例化。<br/>抽象类的**非静态**方法不能有方法体。 | ![image-20200821120456282](https://oss.ydjsir.com.cn/img/image-20200821120456282.png) <br/>更为明确且适用性更广的法则是迪米特法则。 |

> 希望最多只有一个实例？用`getInstance`的单件模式！不希望实例化？把构造方法变成`private`的。

| 编译时                                             | 执行时                                  |
| -------------------------------------------------- | --------------------------------------- |
| 编译器决定你是否能调用某个方法                     | 执行时，JVM虚拟机决定实际哪个方法被调用 |
| 依据引用变量的类型，而不是引用变量指向的对象的类型 | 依据实际引用变量指向的对象的类型        |

多态通过分离“做什么”和“怎么做”，从另一角度将接口和实现分离开来。

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 一个对象包含了了从每一个超类（父类）中继承的所有东西。<br/>也意味着每一个对象实际也是其超类的类型的对象。<br/>每个对象都是其父类的对象。<br/>这里就要注意到JAVA在编译的时候对象类型的转换了。为辅助判断，你可以使用`isInstanceOf` 方法 | <img src="https://oss.ydjsir.com.cn/img/image-20200821132132635.png" alt="image-20200821132132635" style="zoom:50%;" /> |

注意到你不能Override父类的私有方法！因为你继承了它，你却不能改动它。

### 接口

| 两个父类？我们要杜绝这样的死亡菱形！                         | 改用接口的方式，接口可以继承一到多个<br/>接口也可以继承接口。<br/>接口可以看作是一个100%抽象的抽象类 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="https://oss.ydjsir.com.cn/img/image-20200821133327397.png" alt="image-20200821133327397" style="zoom:67%;" /> | ![image-20200821111529096](https://oss.ydjsir.com.cn/img/image-20200821111529096.png) |

接口：一种约束，一种承诺！

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **显式地使用具体的类**<br/>• 锁定某个具体的实现<br/>• 丧失了可扩展性<br/>• 丧失了灵活性<br/>**按接口编程**<br/>• 增加开发的可并行性<br/><br/>• 子类必须保持和父类同样的接口<br/>• 子类必须继承了了父类的实现<br/>• 一旦父类脆弱发生变化，就会对子类造成很⼤的麻烦 | ![image-20200821134534201](https://oss.ydjsir.com.cn/img/image-20200821134534201.png) |

JAVA8新增接口中的Default方法。

**接口和抽象方法不可相互替代！**

| 接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。 | 从设计理理念上，接口反映的是 “like-a” 关系，抽象类反映的是 “is-a” 关系。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法，无法保存状态（state），抽象方法中可以。 | 抽象类不能在 java 8 的 lambda 表达式中使⽤用。               |

• default 关键字只能在接口中使用（以及用在 switch 语句的 default 分支），不能用在抽象类中。

• 接口中的静态方法必须是 public 的，public 修饰符可以省略，static 修饰符不能省略。

• 即使用了 java 8 的环境，一些 IDE 仍然可能在一些代码的实时编译提示时出现异常的提示（例如无法发现 java 8 的语法错误），因此不要过度依
赖 IDE。

> 其实在IDEA里面你可以特别指示它按照哪个Java版本的语法进行检查的。

### 可修改性

| Client代码 | 若发生修改，重新编译，各项开销极大！ |
| ---------- | ------------------------------------ |
| 大量的     | 分散的                               |

| 可修改性                                      | 可扩展性                                                | 灵活性                                                |
| --------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------- |
| • 对已有实现的修改<br/>• 希望不影响Client代码 | • 对新的实现的扩展<br/>• 希望不不影响Client使用类的代码 | • 对实现的动态配置<br/>• 希望不影响Client使用类的代码 |

组合和继承都允许你在新的类中设置子对象（subobject），组合是显式地这样做的，而继承则是隐式的。

组合技术通常用于你想要在新类中使用现有类的功能而非它的接口的情形。

### 初始化与释放的顺序

初始化的时候先调用父类构造方法，后调用子类构造方法。释放的时候恰好相反。

事实上，⼀一个类的初始化包括3个步骤：

• 加载（Loading），由类加载器执行，查找字节码，并创建一个Class对象（只是创建）；

• 链接（Linking），验证字节码，为静态域分配存储空间（只是分配，并不初始化该存储空间），解析该类创建所需要的对其它类的应用；

• 初始化（Initialization），⾸先执行静态初始化块static{}并初始化静态变量（文本顺序），执行静态方法（如构造方法）。

| 可能造成类被初始化的操作           |                                                      |
| ---------------------------------- | ---------------------------------------------------- |
| 创建一个Java类的实例对象           | 调用一个Java类的静态方法                             |
| 为类或接口中的静态域赋值           | 访问类或接口中声明的静态域，并且该域的值不是常值变量 |
| 在一个顶层Java类中执行assert语句句 | 调用Class类和反射API中进行反射操作                   |

常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化。比如说下面的代码。

```java
class A{
	static int value = 100;
	static{
		System.out.println("类A初始化");
	}}
class B extends A{
static{
	System.out.println("类B初始化");}}
public class StaticFieldInit{
	public static void main(String[] args){System.out.println(B.value);}}
/** 最终输出
* 类A初始化
* 100
*/
```

当访问一个Java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化。

通过数组定义来引用类，不会触发类的初始化。

当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，**只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口**。调用**类**中的 static final 常量时**并不会触发该类的初始化**，但是调用**接口**中的 static final常量时便**会触发该接口的初始化**。

### 统一建模语言（Unified Modeling Language,UML）

一组用于描述和设计软件的图形表示法，通常用于面向对象设计领域。

1. 通常对于UML的使用方法：草稿、蓝图与程序设计语言。

2. 常见的9种UML图：用例图、类图、对象图、顺序图、协作图、状态图、活动图、构件图、部署图。

#### 顺序图

表达了对象之间如何通过消息的传递来完成⽐较⼤的职责。也称为调用图。在IDEA里面可以用`SequenceDiagram` 生成。

#### 用例图

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **⽤例是相对独⽴的**<br/>• 取钱？~~填写取款单？~~<br/>**用例的执⾏结果对参与者来说是可观测的和有意义的**<br/>• ~~登陆系统？~~后台进程监控？<br/>**这件事必须有⼀个参与者发起。**<br/>• ATM吐钞票？<br/>**用例必须是以动宾短语形式出现的**<br/>**⼀个用例就是⼀个需求单元、分析单元、设计单元、开发单元、测试单元，甚⾄部署单元。**<br/> | ![image-20200821113845419](https://oss.ydjsir.com.cn/img/image-20200821113845419.png) |

### 封装

1. 封装性：类可以实现信息的隐藏和访问的控制的特性。

2. 通过访问权限控制，可以实现类的封装。

3. 作用：隐藏类的实现细节，将类对外提供服务的接口和内部的具体实现进行分离，这有助于在不影响对类的使用的情况下修改类内部的实现。另一个作用是控制对成员变量的访问。

## Java技术

1. JAVA技术主要部分：JAVA语言、JAVA运行环境、类库。
2. JAVA运行环境（JRE）**：是在任何平台上运行Java编写的程序都需要用到的软件。包括了**java****虚拟机（****JVM****）**、类库、其它插件和文档。
3. Java有非常多的类库，最重要的是**JDK**。

### 容器（Container）

1. 容器（Container）：一种新的对象类型，该对象类型拥有对需要创建的对象的引用，并可以根据需要调整自身的容量。

2. JAVA中主要有两中：Collection和Map。

3. Collection：包含了一组相互独立的元素，可以进一步分为List和Set两种。

4. Map：提供了一组键-值对，要求所有元素的键不得重复。(自变量和因变量)

## 虚拟机与实体机

### 虚拟机

1.在计算机科学中，虚拟机是指可以像真实机器一样运行程序的计算机的软件实现。

2.虚拟机的一个本质特点是运行在虚拟机上的软件被局限在虚拟机提供的资源里——它不能超出虚拟世界。

1.基于这种虚拟机，用户可以运行任何操作系统，比如可以在他们的虚拟电脑上运行不同的操作系统。

2.常见的产品包括：VMare，VirtualBox，Parallels等。

### 寄存器（Registers）

1.数据寄存器（Data Register）

2.寻址寄存器（Addressing Resister）

3.程序计数器寄存器（Program counter resister）

### 输入和输出（Input and Output）

1.I/O映像：创建I/O涉及的二进制仿真，使其对于CPU而言，“看上去”就像普通的内存段。

2.CPU不依赖要与计算机进行交互的I/O设备。

| 冯诺依曼架构                                                 | 理解内存                                                     | Linux逻辑内存地址空间                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![img](https://oss.ydjsir.com.cn/img/clip_image001.jpg) | <img src="https://oss.ydjsir.com.cn/img/image-20200821102104374.png" alt="image-20200821102104374" style="zoom:67%;" /> | ![image-20200821102158649](https://oss.ydjsir.com.cn/img/image-20200821102158649.png) |

 这部分内容又可以与JVM部分结合，详细展开会放在`JVMBasic` 的内容中。

 

 